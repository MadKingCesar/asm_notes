Registers are 16 bits in size but require 20 bits to get an address. To get a location in memory you need to put the address into two seperate registers.
One will contain the offset, and the other will contain the segment address (written segment:offset)

//General segments
CS        Code segment (Where code is read and written)
DS        Data segment (Where values are stored, VARS)
ES        Extra segment (Extra space)
SS        Stack segment (Temporary storage of data and addresses)

//General-purpose registers
AX   BX    CX     DX    SP             BP            SI              DI
ACC  BASE  COUNT  DATA  STACKPOINTER   BASEPOINTER   SOURCE INDEX    DESTINATION INDEX

AX, BX, CX, DX is split into 2 8bit registers (AH, AL & BH, BL and so on)

//Instructions
JMP     Jump to segment:address
INC     Increase
DEC     Decrease
MOV     Move bytes from one place to another (Usually between registers)

//Ilegal instructions
MOV IMDATA (ex: 17), BX     Only the source operand may be immediate data
MOV SI, [SS]                Segment registers may not address memory data
MOV [SI], [BX]
MOV CS, SS
MOV BX, ES:[BX]

the brackets are known as memory data and it indicates that the "contents of memory" and not "contents of a register" is being addressed. Another way to do this is using a segment override prefix (example: MOV CS:[SI], AX     move the contents of AX into a location at an offset (contained in SI) into the CS segment),  if you don't specify CS:[SI] it would simply ASSUME that DS is the segment you want and would move the content into DS:SI. The segment override prefix is a single binary byte (26H). Rather than taking the value inside BX it takes the offset of BX in memory, more or less as I understand it)
